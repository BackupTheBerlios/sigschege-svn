% Copyright 2004, 2005 by Ingo Hinrichs, Ulf Klaperski
%
% This file is part of Sigschege - Signal Schedule Generator
% 
% #############################################################################
%
% Sigschege is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
% 
% Sigschege is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with the Sigschege sources; see the file COPYING.  
%
% #############################################################################
%
% $Id$
%
% Sigschege User Manual
%


\documentclass[11pt]{article}

\setlength{\parskip}{1.5ex plus0.5ex minus 0.5ex}
\setlength{\parindent}{0em}

\begin{document}

\begin{center}
\Huge Sigschege

\vspace{1cm}

\LARGE User Manual

\vspace{3cm}

Written by Ulf Klaperski

\vspace{1cm}

Created from \verb$Revision$
  
\end{center}

\eject

\section{Introduction}
\label{sec:intro}

Sigschege is an application to create timing diagrams for digital electrical circuits.

Currently the only available user interface is a Python plugin. A graphical user
interface is planned for later releases.

\section{Anatomy of a Timing Diagram}
\label{sec:anatomy}

\subsection{States and State Maps}
\label{subsec:statemap}

States in Sigschege are defined by a string. The interpretation of this string
is defined by a state map that is usually a property of the signal.  

If a state is not found in the state map it is drawn as ``X'' and the string
will be shown. This way every unkown value will automatically be represented as
a named bus value.

The properties of a state are shown in table \ref{tab:statemap}.

\begin{table}[htbp]
  \centering
  \begin{tabular}[l]{l|l}
    \textbf{Properties}&\textbf{Values}\\\hline
    Visualization&0, 1, X, Z\\
    showString&Boolean\\\hline
  \end{tabular}
  \caption{Properties of a state}
  \label{tab:statemap}
\end{table}

By default every signal has a state map which defines the values 0, 1, Z and
X. These values are defined to be shown without a label with their expected
visualization, which is a bottom line for 0, a top line for 1, a middle line for
Z and top and bottom line for X. If the signal is supposed to represent a bus
which could accidentally have one of the aforementioned values the state map has
to be flushed.


\section{The Python Interface}
\label{sec:python}

\subsection{Running Sigschege}

The \texttt{sigschege} binary is simply an enhanced Python interpreter. The
usual way to create a timing diagram is to write a Python script which uses the
additional functions. We recommend the extension \texttt{.spy} (Sigschege PYthon) for these
scripts. To process a sigschege script just run:

\begin{center}
  \texttt{sigschege my-interface-protocol.spy}
\end{center}


\subsection{Creating a Timing Diagram}

Sigschege implements the \texttt{Sigschege} namespace. To create a timing
diagram just instantiate a \texttt{TimingDiagram} object from this namespace:


\begin{center}
  \texttt{Sigschege.TimingDiagram(<startTime>, <endTime>)}
\end{center}

Both times are floating point values.
This function must be stored in a variable for later access. A real call will
look like:

\begin{center}
  \texttt{td = Sigschege.TimingDiagram(0.0, 50.0)}
\end{center}

\subsection{Implementing Signals}
\label{sec:sig}

Signals can be created with \texttt{createSignal}. It can take the following
arguments:

\begin{description}
\item[label] The label which will be printed in the text area on the left side.
\item[defaultSlope] \emph{optional} The default slope for all events. Default is 0.
\item[before] \emph{optional} Another element of the timing diagram to insert this element before.  
\end{description}

\begin{center}
  \texttt{sig\_clk = td.createSignal(label=''Clock'', defaultSlope=0.5)}
\end{center}

\subsection{Creating events}
\label{sec:evt}

Events can be added to an existing signal with the \texttt{addEvent} method.

\texttt{<signal>.addEvent(<time>, <stateValue>, [stateName])}

The stateValue determines the value of the new state. The standard values are 1,
0, X, Z or Named. For all other strings the value is set to Named and the string
is used as stateName. 
The optional stateName gives the name of the state as it should be printed. 

In order to draw a ''1'' state (top line, no label):

\texttt{clock.addEvent(50, ''1'')}

If you want to have a bus value ''1'' you can set it as a Named state with name ''1'':

\texttt{clock.addEvent(50, ''Named'', ''1'')}

As a special case, it is also possible to draw value ''1'' (top line) with a
label, e.g. ''H'' for a VHDL weak ''1'':

\texttt{clock.addEvent(50, ''Named'', ''1'')}

The following two examples are identical:

\texttt{clock.addEvent(50, ''6'')}\\
\texttt{clock.addEvent(50, ''Named'', ''6'')}



\subsection{Instantiating a Time Scale}
\label{sec:tis}



\subsection{Exporting Timing Diagrams}
\label{sec:exp}



\end{document}

